#include <iostream>
#include <vector>
#include <GLFW/glfw3.h>


int main()
{
	std::cout << "Part30::链接外包-二进制库-静态链接" << std::endl;
	{
		// 确切的说是GLFW
		//the cherno : 把包都下下来放到项目里,方便迁移不用再下.建议自己下源码放项目里编译,快速开发就用预编译的包
		int a = glfwInit();
		std::cout << a << std::endl;
		//预编译库布局
		//	include目录(包含目录:头文件) 与 library目录(库目录)
		//	library中是预编译的二进制文件,我们通过引用include中的.h文件来调用这些二进制文件中的函数
		//	library有可能包含两种库 静态库 与 动态库 ,我们可以选择 动态链接 或 静态链接 这些库
		//	静态链接lib : 被放入你生成的.exe文件中 ,你不需要再去其他地方找 //可以更快
		//	动态链接dll : 你的.exe在运行时仍调用这些lib文件,如果找不到则不能运行 //减少内存占用
		//	如果使用dll,有时还会有配套的dll.lib , 提供一些函数与符号的位置信息,当然没有dll.lib也能使用dll,不过那就是要 查找 函数定义了

		//	include .h包含了函数声明 ,我们还需要告诉编译器 去哪链接库 ,来获得这些函数的定义

		//注: lib-vc2012 等这种命名方式的意思是,这是由 vc编译器2012版本 编译出的 lib , 
		//lib-mingw mingw是另一种c++编译器

		//你最好在使用时需要对照自己使用的编译器种类选择对应版本的lib , 至少编译器的种类相近 , 减少兼容性出错的可能性


		//为项目添加依赖库

		//项目 - 属性 - c++ - 常规 - 附加包含目录 - 添加 // 最好最好写相对目录写include
		// $(SolutionDir) 你的sln项目文件所在路径 ,当然你可以在 宏 中查看这些宏代表的路径
		//然后你就可以 #include "附加包含目录的相对路径 .h"或者<>

		//"" 先检查项目的相对路径,然后去问编译器的附加包含目录 一般用来引用包含在项目内(甚至自己写的).h文件
		//<> 问编译器的附加包含目录 , 一般用来引用 外部库 

		//下一步,你需要提供include的头文件的实际实现 lib或dll 即 链接到库
		//项目 - 属性 - 连接器 - 常规 - 附加依赖库 // 写lib目录
		//项目 - 属性 - 连接器 - 输入 - 附加依赖项 // 写库目录相对库文件名称-选择载入lib库中的lib

		//解决方案
		//K : warning LNK4098: 默认库“MSVCRT”与其他库的使用冲突；请使用 /NODEFAULTLIB:library
		//右击工程 - 属性 ”配置属性 - 链接器 - 命令行” 添加：  /NODEFAULTLIB:"libcmt.lib"
	}

	std::cout << "Part31:链接外包-二进制库-动态链接" << std::endl;
	{
		//动态链接 依然需要头文件引用
		//glfw 添加 dll.lib
		//生成后 把dll文件拉到 .exe相对路径下//你可以设置搜索路径 , 但是用根目录绝对没问题


		//项目 - 属性 - C++ - 预处理:可以设置定义 defined() 哪些 ,这对预处理头文件有影响 , 与dll的import有关
	
	}

}